------------------------------------------------------------------Добавление данных, оператор INSERT------------------------------------------------------------------------
   
Оператор INSERT предназначен для добавления (вставки) данных в таблицу. Общая структура запроса:

    -------------------------------------------------------------------------------
    INSERT INTO имя_таблицы [(поле_таблицы, ...)]
    VALUES (значение_для_добавления, ...)
    -------------------------------------------------------------------------------

Как видно из общей структуры, мы можем добавлять несколько значений в несколько стобцов. Для это нужно заключить поля таблиц в которые нужно добавить значения и сами 
значения для добавления в круглые скобки. Т.е.:

    -------------------------------------------------------------------------------
    INSERT INTO clients (id, name, amount)
    VALUES (312, "Александр", 3200)
    -------------------------------------------------------------------------------

Значения можно также добавить, используя не VALUES, а SELECT, но в таком случае значения для добавления не нужно объединять в круглые скобки.

    -------------------------------------------------------------------------------
    INSERT INTO clients (id, name, amount)
    SELECT 312, "Александр", 3200
    -------------------------------------------------------------------------------

При добавлении новой записи, важным является вопрос указания идентификатора. Для решения вопроса уникальности этого идентификатора, можно использовать следующий подход:
каждый новый id = количество элементов в таблице + 1, т.е.:

    -------------------------------------------------------------------------------
    INSERT INTO Clients (id, name, amount)
    SELECT COUNT(*) + 1, "Александр", 3200 FROM Clients
    -------------------------------------------------------------------------------

Тут важно понимать, что для корректного расчета id нужно использовать именно SELECT, т.к. в данном случае мы как бы создаем подзапрос, который считает количество 
сущностей в таблице Clients. А значит у вызова агрегатной функции COUNT() есть контекст выполнения. Если бы мы использовали синтаксис с VALUES, нам бы пришлось стереть
"FROM Clients", а значит агрегатная функция, которая всегда должна вызываться в контексте какой-либо таблицы, была бы вызвана без контекста, а значит мы получили бы ошибку

В MySQL реализована возможность автоматически сгенерировать первичный ключ (id) для определенной сущности. Она задается на стадии шаблонизации таблицы. Т.е. при создании
таблицы для поля первичного ключа добавляется параметр AUTO_INCREMENT, что в свою очередь означает, что в случае если в данное поле при вставке передано NULL или 0, то
первичный ключ будет сгенерирован автоматически. Вот так выглядить присваивание такого функционала полю первичного ключа:

    -------------------------------------------------------------------------------
    CREATE TABLE Goods (
        good_id INT NOT NULL AUTO_INCREMENT
        ...
    );
    -------------------------------------------------------------------------------

В данном примере 
    good_id - название столбца
    INT - тип данных хранящийся в столбце
    NOT NULL - ограничение указывающее, что в данном столбце не могут находиться NULL поля
    AUTO_INCREMENT - специальное свойство, которое автоматически увеличивает значение столбца для каждой новой записи

Соотвтетсвенно, запрос к такого рода таблице должен выглядеть таким образом:

    -------------------------------------------------------------------------------
    INSERT INTO Goods VALUES (NULL, 'Table', 2);
    -------------------------------------------------------------------------------

либо таким:

    -------------------------------------------------------------------------------
    INSERT INTO Goods (good_name, type) VALUES ('Table', 2);
    -------------------------------------------------------------------------------

в случае, если мы перечисляем конкретные поля которые хотим вставить (можем просто не обращаться к полю с первичным ключем, СУБД сделает это за нас автоматически)



-----------------------------------------------------------------Обновление данных, оператор UPDATE-------------------------------------------------------------------------

Для редактирования данных в SQL-таблицах используется оператор UPDATE. Общая структура запроса:

    -------------------------------------------------------------------------------
    UPDATE имя_таблицы
    SET поле_таблицы1 = значение_поля_таблицы1,
        поле_таблицыN = значение_поля_таблицыN
    [WHERE условие_выборки]
    -------------------------------------------------------------------------------
После ключевого слова UPDATE указывается таблица, в которой будут изменены данные, а затем с помощью ключевого слова SET, через запятую перечисляются изменения в формате:
"поле_таблицы = новое_значение". Для того чтобы найти необходимую ячейку можно использовать опционально, ключевое слово WHERE, которое позволяет найти конкретную сущность
внутри таблицы и менять (UPDATE'ить) соответствующее поле именно этой сущности.

Соответственно, чтобы, например, изменить имя клиента, нужно выполнить следующий запрос:

    -------------------------------------------------------------------------------
    UPDATE Сlients
    SET member_name = "Егор Семёнов"
    WHERE member_name = "Егор Зварыкин";
    -------------------------------------------------------------------------------

Важно отметить, что при обновлении данных, если пропустить оператор WHERE, то будут перезатерты все поля таблицы.

В запросах на обновление данных можно менять данные операясь на предыдущие данные. Т.е.:

    -------------------------------------------------------------------------------
    UPDATE Payments
    SET unit_price = unit_price * 2;
    -------------------------------------------------------------------------------



-----------------------------------------------------------------Удаление данных, оператор DELETE---------------------------------------------------------------------------

Для удаления данных из таблицы, в SQL существуют операторы DELETE и TRUNCATE (срезать, усечь). Наиболее универсальным и безопасным из них является DELETE. Общая структура
запроса:

    -------------------------------------------------------------------------------
    DELETE FROM имя_таблицы
    [WHERE условие_отбора_записей];
    -------------------------------------------------------------------------------

ВАЖНО!!! Если также как и в случае с UPDATE, не указать ключевое слово WHERE, то будут удалены ВСЕ данные из указанной таблицы.

DELETE - удаляет значения одно за одной поочередно (работает как цикл)
TRUNCATE - удаляет таблицу целиком и пересоздает её (более проиводительный способ удаления)

Общая структура запроса с TRUNCATE:

    -------------------------------------------------------------------------------
    TRUNCATE TABLE имя_таблицы;
    -------------------------------------------------------------------------------

Оптимизатор запросов СУБД MySQL автоматически использует оператор TRUNCATE, если оператор DELETE не содержит условия WHERE или конструкции LIMIT.
Однако у оператора TRUNCATE есть ряд отличий:

    - Не срабатывают триггеры, в частности, триггер удаления
    - Удаляет все строки в таблице, не записывая при этом удаление отдельных строк данных в журнал транзакций
    - Сбрасывает счётчик идентификаторов до начального значения
    - Чтобы использовать, необходимы права на изменение таблицы

Исходя из данных особенностей, можно сделать вывод о том, что TRUNCATE более опасный метод

Внутри оператора DELETE, можно использовать объединение данных с помощью JOIN.

    -------------------------------------------------------------------------------
    DELETE Reservations FROM Reservations 
    JOIN Rooms ON Reservations.room_id = Rooms.id
    WHERE Rooms.has_kitchen = false;
    -------------------------------------------------------------------------------

Для удаления данных из многотабличного запроса, необходимо указывать из какой именно таблицы мы удаляем данные. Например, если в предыдущем примере, нам было бы 
необходимо удалить, помимо резервации, еще и жилье, которое не подошло под критерий Rooms.has_kitchen = false, то после оператора DELETE необходимо было бы добавить 
также название таблицы Rooms, т.к. жилье находится именно в ней. 

    -------------------------------------------------------------------------------
    DELETE Reservations, Rooms FROM Reservations 
    JOIN Rooms ON Reservations.room_id = Rooms.id
    WHERE Rooms.has_kitchen = false;
    -------------------------------------------------------------------------------