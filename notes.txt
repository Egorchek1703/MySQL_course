-----------------------------------------------------------------Операторы IS NULL, BETWEEN, IN-----------------------------------------------------------------------------

Помимо логических операторов рассмотренных в предыдущем уроке, в MySQL существует еще несколько полезных операторов, таких как: IS NULL, BETWEEN, IN.

Оператор IS NULL позволяет узнать равно ли проверяемое значение NULL, т.е. пустое ли значение. Для примера выведем всех преподавателей, у кого отсутствует отчество:
    -------------------------------------------------------------------------------
    SELECT * FROM Teacher
    WHERE middle_name IS NULL;
    -------------------------------------------------------------------------------

Оператор BETWEEN min AND max позволяет узнать расположено ли проверяемое значение столбца в интервале между min и max, включая сами значения min и max (отрезок).
    -------------------------------------------------------------------------------
    SELECT * FROM Payments
    WHERE unit_price BETWEEN 100 AND 500;
    -------------------------------------------------------------------------------

Оператор IN позволяет узнать входит ли проверяемое значение столбца в список определённых значений.
    -------------------------------------------------------------------------------
    SELECT * FROM FamilyMembers
    WHERE status IN ('father', 'mother');
    -------------------------------------------------------------------------------


-------------------------------------------------------------------------Оператор LIKE--------------------------------------------------------------------------------------

Иногда возникает ситуация где нам нужно отсоритровать выборку данных исходя из каких-то полей, например, исходя из поля email в таблице Users, мы можем показать только
тех пользователей, у которых домен почты соответствует "(что-то...)@mail.(что-то...)". Для такого внутристрокового поиска существует оператор LIKE. Он также как и функция
INSTR() осуществляет поиск субстроки внутри главной строки (поля в таблице), но в отличие от неё возвращает сам элемент, а функция возвращает всего лишь индекс с которого
начинается субстрока внутри главной строки. Чтобы применить оператор LIKE в условном выражении, нам необходимо записать название столбца по которому будет происходить
исключение и после него указать LIKE с строкой которую должны содержать поля таблицы. Соответственно, если поле таблицы не содержит данную субстроку, оно вывыдено не будет.
    -------------------------------------------------------------------------------
    SELECT name, email FROM Users
    WHERE email LIKE "%@mail.%";
    -------------------------------------------------------------------------------

Как видно из примера, мы используем внутри шаблонной строки специальный символ "%" который означает любое количество каких-либо символов (в нашем случае и в начале и в 
конце строки). Также существует символ "_" который означает любой одиночный символ

В MySQL по умолчанию такие шаблоны не чувствительны к регистру.


-------------------------------------------------------------------Сортировка. Оператор ORDER BY---------------------------------------------------------------------------

При выполнении SELECT-запроса строки данных возвращаются в неопределенном порядке, который зависит от расположения данных на диске а также от плана соединения с 
сканирования. На этот порядок пологаться не стоит, поэтому сущесвтуют специальный оператор для сортировки данных (упорядочивания) ORDER BY. Синтаксис запроса следующий:

    -------------------------------------------------------------------------------
    SELECT поля_таблиц FROM наименование_таблицы
    WHERE ...(условие)
    ORDER BY название_столбца [ASC | DESC];
    -------------------------------------------------------------------------------
где ASC - сортировка по возрастанию (по умолчанию), а DESC - сортировка по убыванию

Для сортировки результатов по двум или более столбцам их следует указывать через запятую.

    -------------------------------------------------------------------------------
    SELECT поля_таблиц FROM наименование_таблицы
    WHERE ...(условие)
    ORDER BY название_столбца DESC, название_другого_слобца DESC;
    -------------------------------------------------------------------------------

Сортировка строковых значений происходит в алфавитном порядка, а числа просто сравниваются между собой.
При сортировке двух и более столбцов, изначально данные сортируются по первому столбцу, а затем те сущности, которые имеют одинаковое значение внутри первого столбца, 
сортируются по второму столбцу и указанному направлению (ASC | DESC)


-------------------------------------------------------------------Группировка. Оператор GROUP BY---------------------------------------------------------------------------

Иногда бывает необходимо вывести группы данных. Например, если у нас есть таблица данных с квартирами, которые мы сдаем и эти квартиры имеют различный тип 
(например, некоторые мы сдаем на одного человека, а некоторые делят между собой несколько людей (shared room)). Очевидно, что для нас может быть важна информации о каждой
группе, а значит, нам необходимо как-то получить эти группы. Для этого и сущесвтует оператор GROUP BY, после которого указывается колонка (столбец) данных, по которому 
и будут определены группы данных из таблицы.

    -------------------------------------------------------------------------------
    SELECT home_type FROM Rooms
    GROUP BY home_type;
    -------------------------------------------------------------------------------

В данном примере определяем группы по полю home_type (например, у нас 3 различных варианта данных в этом поле, а значит групп будет тоже 3). Результат выполнения
данного запроса будет просто три строки, т.к. оператор GROUP BY позволяет вернуть не сами записи группированные по какому-то отдельному столбцу, а количество групп и 
значения, по которым эти группы были определены определяются.

ВАЖНО: для GROUP BY все значения NULL трактуются как равные, т.е. при группировке по полю, содержащему NULL-значения, все такие строки попадут в одну группу.

Т.к. после выполнения запроса с помощью GROUP BY мы получаем группы, значит мы уже не можем просто выводить значения определенных столбцов, как мы делали это с отдельными 
сущностями. Это связано с тем, что в каждой группе может быть несколько записей по определеннмоу столбцу и в каждой из них в этом поле может быть разное значение.

Значит вместе с оператором GROUP BY мы можем вызывать только литералы, т.е. фиксированные значения, которые никак не связаны с сущностями или группами полученными после
запроса.
А также мы можем выводить агрегатные функции, которые применяются ко всем сущностям группы по определенному столбцу. Например, после того как мы получили группы по критерию
"количество персон на которые квартира сдается" (shared_room или solo_room или family_room), мы можем посчитать среднее значение стоимости аренды для каждой группы с 
помощью агрегатной функции AVG() передав внутрь неё в качестве параметра то поле, по которому мы хотим посчитать среднее значение для каждой группы.

При группировке данных по двум и более полям принцип остается такой же как и при сортировки с помощью ORDER BY, т.е. сначала данные группируются по первому признаку 
(столбцу), а затем разбиваются на более подгруппы исходя из второго и последующих столбцов. Т.е. если у нас 3 группы по критерию "количество персон на которые квартира 
сдается" и мы группируем данные по другому критерию, например, "внутри есть TV", то каждая из полученных 3-х групп разделяется на две группы:

type        -       has_TV

shared_room -       TRUE
shared_room -       FALSE

solo_room   -       TRUE
solo_room   -       FALSE

family_room -       TRUE
family_room -       FALSE


Важно отметить, что очевидно, если внутри группы нет сущностей, которые не выделяют вторую группу по второму признаку, т.е., например, все комнаты имееют телевизор, то
соответственно, главная группа (family_room) не будет разбита на подгруппы, а будет иметь простую запись family_room - TRUE, что означает что все семейные комнаты имеют
телевизор.


-------------------------------------------------------------------------АГРЕГАТНЫЕ ФУНКЦИИ---------------------------------------------------------------------------------

Агрегатная функция – это функция, которая выполняет вычисление на наборе значений и возвращает одиночное значение. Возвращаемый агрегатной функцией результат должен
быть отражен, как столбец результирующий таблицы запроса, поэтому для этого результата нужно создать отдельны йстолбец в результирующей таблице, а значит логичным будет
использовать "алиас" для результата функции. Т.е.:

    -------------------------------------------------------------------------------
    SELECT home_type, AVG(price) AS avg_price FROM Rooms
    GROUP BY home_type
    -------------------------------------------------------------------------------

Агрегатные функции:

*    SUM(столбец_таблицы) - Возвращает сумму значений по столбцу "столбец_таблицы"
*    AVG(столбец_таблицы) - Возвращает среднее значение по столбцу "столбец_таблицы"
*    COUNT(столбец_таблицы) - Возвращает количество записей (сущностей) по столбцу "столбец_таблицы"
*    MIN(столбец_таблицы) - Возвращает минимальное значение по столбцу "столбец_таблицы"
*    MAX(столбец_таблицы) - Возвращает максимальное значение по столбцу "столбец_таблицы"

Агрегатные функции применяются для значений, не равных NULL. Исключением является функция COUNT()


----------------------------------------------------------------------------ОПЕРАТОР HAVING---------------------------------------------------------------------------------

После того как мы группировали определенные сущности и посчитали с помощью агрегатных функций определенные показатели, нам может понадобиться исключить часть групп по
определенному критерию, как мы делали это ранее с помощью оператора WHERE условие. В таком случае логичным кажется запрос с следующим синтаксисом:
    
    -------------------------------------------------------------------------------
    SELECT home_type, AVG(price) as avg_price FROM Rooms
    GROUP BY home_type
    WHERE avg_price > 50
    -------------------------------------------------------------------------------

Однако на данном этапе ничего не будет работать ввиду того, что порядок выполнения SQL-запроса не позволяет применять какие-либо условия к группам сущностей с помощью
оператора WHERE. Для групп вместо него используется оператор HAVING.

Такое поведение обуславливается порядком SQL-запроса:

1. FROM - получение данных из таблицы
2. WHERE - фильтрация записей по определенному условию
3. GROUP BY - группировка отфильтрованных данных
4. HAVING - фильтрация групп по определенным условиям
5. ORDER BY - сортировка данных в определенном порядке

Соотвтественно, в запросе выше мы пытаемся обратиться avg_price у образовавшихся групп ещё до группировки, хотя само поле появляется только после группировки и сопуствующего
выполнения агрегатной функции AVG().




