---------------------------------------------------------------------Многотабличные запросы, JOIN---------------------------------------------------------------------------

В предыдущих уроках описывалась работа только с одной таблицей базы данных. В реальности же очень часто приходится делать выборку из нескольких таблиц, каким-то образом 
объединяя их. Для такого объединения и существует ключевое слово JOIN.

Например, у нас есть таблица с членами семьи, включающая id и name члена семьи. И есть таблица покупок включающая id_члена_семьи (совершившего покупку) и price (цену
покупки). Мы хотим узнать кто совершил покупки и на какую сумму. 
-----------------------
FamilyMembers:
-----------------------
id  -   name
-----------------------
1   -   Григорий Орехов
2   -   Анатолий Орехов
3   -   Евгения Орехова
4   -   Снежана Орехова
-----------------------


-------------------------
Payments:
-------------------------
id_члена_семьи  -   price
-------------------------
1               -   1200
2               -   3200
3               -   2400
4               -   6800
-------------------------


При этом мы можем вывести данные из таблицы Payments с помощью запроса:
   
    -------------------------------------------------------------------------------
    SELECT id_члена_семьи, price FROM Payments
    -------------------------------------------------------------------------------

Однако в таком случае мы получим лишь идентификаторы и результирующая таблица будет плохо читаемая и соответственно мы хотим вместо id_члена_семьи выводить его имя полное
имя из таблицы FamilyMembers. Значит нам нужно объединить поле name FROM FamilyMembers и поле price FROM Payments так чтобы и покупки и имена в новой таблице 
соответствовали id_члена_семьи.

Общая структура многотабличного запроса:
    -------------------------------------------------------------------------------
    SELECT поля_таблиц
    FROM таблица_1
    [INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_2
        ON условие_соединения
    [[INNER] | [[LEFT | RIGHT | FULL][OUTER]] JOIN таблица_n
        ON условие_соединения]
    -------------------------------------------------------------------------------

Как видно по структуре соединения бывают:
    - внутренним INNER (по умолчанию)
    - внешним OUTER, при этом внешнее соединение делится на левое LEFT, правое RIGHT и полное FULL
Более подробно с соединениями мы ознакомимя с ледующих уроках.


Соответственно, наш запрос исходя из структуры должен выглядеть так:

    -------------------------------------------------------------------------------
    SELECT id_члена_семьи, name, price FROM Payments
    INNER JOIN FamilyMembers
        ON Payments.id_члена_семьи = FamilyMembers.id
    -------------------------------------------------------------------------------

В нем мы грубо говоря, объединяем две таблицы (дописываем вторую таблицу(которая после INNER JOIN) к первой) после ключевого слова ON в условии, а именно говорим, 
что у нас для полей таблицы Payments теперь нужно найти соответствующие id из таблицы FamilyMembers и получается что сущности из таблицы FamilyMembers РАВНЫ по id-шникам
сущностям из таблицы Payments

То есть наша табилца выглядит следующим образом:

-------------------------------------------------
Result:
-------------------------------------------------
id_члена_семьи  -   name                -   price
-------------------------------------------------
1               -   Григорий Орехов     -   1200
2               -   Григорий Орехов     -   3200
3               -   Григорий Орехов     -   2400
4               -   Григорий Орехов     -   6800
-------------------------------------------------

Поэтому для того чтобы объединить две таблицы по общему полю нам достаточно использовать 

    -------------------------------------------------------------------------------
    INNER JOIN НазваниеВторойТаблицы
    ON НазваниеПервойТаблицы.id_элемента_из_первой_таблицы = НазваниеВторойТаблицы.id_элемента_из_второй_таблицы
    -------------------------------------------------------------------------------

Ранее чтобы вывести все поля из таблицы мы использовали символ "*". Теперь при работе с двумя таблицами этот символ означает вывести все поля для первой таблицы 
(в выражении FROM), а занчит чтобы определить для какой таблицы именно мы хотим вывести все поля нам нужно использовать следующий синтаксис в первой строке запроса (в 
выражении FROM):

    НазваниеТаблицы.*

Это сделано для того, чтобы явно дать понять СУБД, из какой именно таблицы мы хотим выводить данные. Например, если мы хотим вывести все данные для первой таблицы, то
можем просто использовать "*", но если хотим вывести все данные для присоединяемой таблицы, нужно сначала указать название таблицы, а затем, через точку обратиться ко всем
ее полям с помощью "*"

Объединение таблиц происходит по определенным правилам, таким как INNER, LEFT, RIGHT, FULL. Когда мы объединяли таблицы из предыдущего примера, мы заведомо предполагали,
что в таблице FamilyMembers находятся все члены семьи обязательно совершавшие покупки отмеченные в таблице Payments. Однако может быть такое, что например, какой-то член
семьи в принципе не совершал покупку. Т.е. таблица Payments может выглядеть так:

-------------------------
Payments:
-------------------------
id_члена_семьи  -   price
-------------------------
1               -   1200
2               -   3200
3               -   2400
-------------------------

В данном примере хоть у нас и есть пользователь с id = 4 в таблице Payments, но он не совершал покупки, а значит мы не должны выводить его в общей результирующей таблице

-------------------------------------------------
Result:
-------------------------------------------------
id_члена_семьи  -   name                -   price
-------------------------------------------------
1               -   Григорий Орехов     -   1200
2               -   Григорий Орехов     -   3200
3               -   Григорий Орехов     -   2400
-------------------------------------------------

Именно такое поведение несет в себе правило пересечения таблиц INNER. Оно выводит только те элементы, которые имеются и пересекаются в обеих таблицах.
Однако иногда бывает важно отобразить и тех членов семьи, которые не совершали покупки, и для этого как раз подходят правила LEFT, RIGHT и FULL.

LEFT выполняет функционал INNER и оставляет только непресеченные (т.е. у них нет соответствий во второй таблице) элементы первой таблицы (той к которой присоединяем)
RIGHT выполняет функционал INNER и оставляет только непресеченные (т.е. у них нет соответствий в первой таблице) элемменты второй таблицы (той которую присоединяем к 
главной с помощью JOIN)
FULL OUTER выполняет функционал INNER и оставляет непересеченные (не имеющие соответствий) из обеих таблиц.

Т.е. в нашем случае, чтобы получить всё равно пользователя с id = 4, нам нужно использовать либо правило RIGHT, либо FULL, т.к. нужно добавить данные из присоединяемой 
таблицы

    -------------------------------------------------------------------------------
    SELECT id_члена_семьи, name, price FROM Payments
    RIGHT JOIN FamilyMembers
        ON Payments.id_члена_семьи = FamilyMembers.id
    -------------------------------------------------------------------------------

СУБД выведет:
-------------------------------------------------
Result:
-------------------------------------------------
id_члена_семьи  -   name                -   price
-------------------------------------------------
1               -   Григорий Орехов     -   1200
2               -   Григорий Орехов     -   3200
3               -   Григорий Орехов     -   2400
4               -   Снежана Орехова     -   NULL
-------------------------------------------------

Как видно из примера, для значений у которых не удалось найти пару, в столбцах из другой таблицы поля заполняться NULL.

Для пересечения таблиц существует также альтернативный синтаксис с использованием ключевого слова WHERE.

    -------------------------------------------------------------------------------
    SELECT family_member, member_name FROM Payments, FamilyMembers
    WHERE Payments.family_member = FamilyMembers.member_id
    -------------------------------------------------------------------------------

ВАЖНО!!! 
Группировку с помощью GROUP BY мы совершаем с после объединения таблиц (что весьма логично)


OUTER:

Внешнее соединение может быть трёх типов: левое (LEFT), правое (RIGHT) и полное (FULL). По умолчанию оно является полным.
Важной особенностью внешнего соединения является факт того, что оно обязательно возвращает как минимум все поля одной из таблиц (LEFT - левой таблицы (той к которой 
присоединяем) RIGHT - правой таблицы (той которую присоединяем) или FULL - все поля обеих таблиц даже если они не пересекаются)

Также важно отметить, что если в какой-то из таблиц, поля которой мы присоединяем, нет пересечения с таблицей к которой мы присоединям и при этом мы сохраняем поля 
присоединяемой таблицы, то для тех сущностей которые не имеют полей в главной таблицы по соответствующим полям будет присвоено значение NULL.


-----------------------------------------------------------------Ограничение выборки. Оператор LIMIT------------------------------------------------------------------------

Для того чтобы ограничить количество получаемых (результирующих) данных необходимо использовать оператор лимит, после запроса "SELECT название_полей FROM название_таблицы".
После ключевого слова LIMIT необходимо использовать два числовых значения. Первое означает сколько строк нужно пропустить от начала, а второе сколько строк вывести в
результирующую таблицу. Т.е. запись формата "LIMIT 3, 5" выведет сущности с 4 по 9 включительно (первые 3 пропускаем и последюущие 5 выводим).
Соответственно, синтаксис запроса выглядит следующим образом:

    -------------------------------------------------------------------------------
    SELECT поле_таблицы
    FROM название_таблицы
    LIMIT количество_пропущенных_записей, количество_записей_для_вывода;
    -------------------------------------------------------------------------------

Также можно воспользоваться более подробным синтаксисом где после ключевого слова LIMIT мы задаем количество выведенных строк, а после ключевого слова OFFSET (смещение),
мы задаем количество строк которые нужно пропустить от начала.


----------------------------------------------------------------------------Подзапросы--------------------------------------------------------------------------------------

Подзапрос - это определенный запрос, использующийся в другом SQL-запросе и имеющий в результате либо 1-у строку и 1 столбец, либо несколько строк и 1 столбец, либо 
несколько строк и несколько стобцов. Соответственно, выделяют три вида подзапросов исходя из результирующей таблицы.

    -------------------------------------------------------------------------------
    SELECT * FROM Reservations
    WHERE Reservations.room_id = (
        SELECT id FROM Rooms ORDER BY price DESC LIMIT 1
    )
    -------------------------------------------------------------------------------

В данном примере, изначально, мы получаем id самой дорогой комнаты которая сдается, а затем выводим данные по неё. Подзапросы оборачиваются круглыми скобками.

* Подзапрос с 1 строкой и 1 столбцом называется скалярным. Чаще всего он используется в условиях ограничения выборки с операторами сравнения. Например, с помощью подзапроса
такого вида можно получить самого младшего члена семьи

    -------------------------------------------------------------------------------
    SELECT * FROM FamilyMembers
    WHERE birthday = (SELECT MAX(birthday) FROM FamilyMembers);
    -------------------------------------------------------------------------------

В данном подзапросе MAX(birthday) выведет самый последний день рождения, т.е. самую ближающую дату к сегодняшнему числу, а далее основнйо запрос выведет данные для 
сущности у которой дата рождения соответствует результату подзапроса.

* Подзапрос с несколькими строками и 1 столбцом. Если подзапрос возвращает несколько строк, то его нельзя использовать с операторами сравнения, как мы это делали со 
скалярными подзапросами. Однако для работы с подзапросами с несколькими строками и одним столбцом можно использовать три дополнительных оператора.

Оператор ALL - сравнивает каждое значение с фиксированным, (указанным в сравнении) по определенному столбцу. Например, запрос, представленный ниже сравнит стоимость всех 
жилых помещений с числом 200, и вернет TRUE только если для каждого помещения (сущности) выполнится условие.

    -------------------------------------------------------------------------------
    SELECT 200 > ALL(SELECT price FROM Rooms)
    -------------------------------------------------------------------------------

Оператор ALL указывается перед подзапросом с одним столбцом и несколькими строками и сравнивает  

Оператор IN - проверяет входит ли какое-то значение в набор значений, которым и может являтся результат подзапроса с 1 столбцом и несколькими строками. То есть, данный 
оператор последовательно сравнивает фиксированное значение с каждым из результата подзапроса (массива) и оставляет это значение в результат выполнения оператора IN, 
если есть совпадение. Т.е. все значения, которые являются фиксированными (там может быть не одно лишь значение, а например, столбец значений из таблицы) сравниваются с 
значениями из подзапроса, и те фиксированные значения, которые включены в результат подзапроса, будут выведены в результирующую таблицу выполнения оператора IN.
Т.е. оператор IN является своего рода фильтром, который для каждого значения столбца user_id проверяет, существует ли это значение в столбце подзапроса (например, 
owner_car_id) и если да, то оставляет это значение в результате, а если нет, то убирает его из результирующей таблицы.

Например, если нам необходимо получить всю информацию о пользователях в случае, если они являются владельцами жилья, то мы можем использовать оператор IN, для того чтобы 
проверить находится ли id пользователя в результате подзапроса, получающего id всех владельцев жилья.

    -------------------------------------------------------------------------------
    SELECT * FROM Users WHERE id IN (
        SELECT DISTINCT owner_id FROM Rooms
    )
    -------------------------------------------------------------------------------

Оператор ANY - делает то же самое что и оператор IN, но возвращает TRUE, если хотя бы одно значение из массива фиксированных значений находит соответствие в результате
подзапроса.

Чтобы сравнивать результаты по многим столбцам нужно также использовать операторы IN, ALL, ANY. При сравнении нескольких фиксированных столбцов из основного запроса, нам
необходимо объединить их с помощью круглых скобок "()" и указать оператор для сравнения, а затем результат подзапроса.
Пример такого сравнения:

    -------------------------------------------------------------------------------
    SELECT * FROM Rooms 
    WHERE (has_tv, has_internet, has_kitchen, has_air_con) IN 
        (SELECT has_tv, has_internet, has_kitchen, has_air_con FROM Rooms WHERE id = "11")
    -------------------------------------------------------------------------------

В данном примере мы выводими все поля сущностей таблицы Rooms, которые по количеству удобств (has_air_con, has_internet, has_kitchen, has_tv) ровно такие же, как и комната
с id = "11".
Сначала мы выполняем подзапрос, который выдает нам необходимые столбцы по комнате 11, а затем сравниваем все комнаты из таблицы Rooms с комнатой 11 по столбцам (has_air_con,
has_internet, has_kitchen, has_tv) и те комнаты с которыми сравнение верно, добавляем в результирующую таблицу.



----------------------------------------------------------------------Коррелированные подзапросы----------------------------------------------------------------------------

Все предыдущие рассматриваемые подзапросы были некоррелированные (независимые). Они могли выполняться автономно от основного запроса и мы могли посмотреть, что они 
возвращают перед тем, как их результат будет использоваться в основном запросе. Коррелированные же подзапросы ссылаются на один или несколько столбцов основного запроса.

Коррелированный подзапрос отличается от некоррелированного подзапроса тем, что он выполняется не один раз перед выполнением запроса, в который он вложен, а для каждой 
строки, которая может быть включена в окончательный результат. Пример:

    -------------------------------------------------------------------------------
    SELECT FamilyMembers.member_name, (
        SELECT SUM(Payments.unit_price * Payments.amount)
        FROM Payments
        WHERE Payments.family_member = FamilyMembers.member_id) AS total_spent
    FROM FamilyMembers;
    -------------------------------------------------------------------------------

Т.е. коррелированный подзапрос, выполняется для каждой записи в основном запросе. Как показано в примере, результат подзапроса можно выводить с помощью алиасов. Тут для
каждой сущности из таблицы FamilyMembers, поле total_spent будет подсчитано индивидуально.

Следует обратить внимание на то, что использование коррелированных подзапросов может вызвать проблемы с производительностью, особенно если содержащий запрос возвращает 
много строк, так как коррелированный подзапрос будет выполняться для каждой строки содержащего запроса отдельно.



-----------------------------------------------------------------Обобщённое табличное выражение, оператор WITH--------------------------------------------------------------

С помощью ключевого слова WITH мы можем создать обособленную таблицу во время выполнения самого запроса и обращаться к этой таблице внутри запроса в дальнейшем. Чтобы 
создать такую таблицу, нужно использовать ключевое слово WITH, затем нами придуманное название таблицы, затем AS и подзапрос который и сформирует необходимую таблицу.
Т.е.

    -------------------------------------------------------------------------------
    WITH Temp_table AS (
        SELECT name, age, salary FROM Workers
            INNER JOIN Salaries 
            ON Workers.id = Salaries.id_of_worker
    )
    SELECT name, salary FROM Temp_table
    WHERE salary >= (SELECT MAX(salary) FROM Salaries)
    -------------------------------------------------------------------------------

В данном случае, мы создаем таблицу формата "имя, возраст, зарплата" путём объединения двух исходных таблиц, а затем с помощью главного запроса к этой таблице и 
подзапроса к ней же, получаем имя и зарплату у работника, у которого зарплата максимальна в нашей временной таблице.

В данной таблице, созданной с помощью WITH, можно задавать названия столбцов (опционально), указав в круглых скобках псевдонимы для них, после название таблицы. Т.е.

-------------------------------------------------------------------------------
    WITH Temp_table (kak_zovut, skolko_let, skolko_zarabativaet) AS (
        SELECT name, age, salary FROM Workers
            INNER JOIN Salaries 
            ON Workers.id = Salaries.id_of_worker
    )
    SELECT name, salary FROM Temp_table
    WHERE salary >= (SELECT MAX(salary) FROM Salaries)
    -------------------------------------------------------------------------------

При необходимости создать две и более таблицы, после синтаксиса создания первой, достаточно поставить запятую "," и указать название новой таблцы и т.д. Т.е. ключевое
слово WITH дублировать не нужно.



---------------------------------------------------------------------Объединение запросов, оператор UNION-------------------------------------------------------------------

Чтобы объединять результаты выполнения запросов в одной таблице существует оператор UNION. Общая структура запроса:

    -------------------------------------------------------------------------------
    SELECT поля_таблиц FROM название_таблицы
    UNION [ALL]
    SELECT поля_таблиц FROM название_таблицы ;
    -------------------------------------------------------------------------------

По умолчанию UNION убирает повторения между таблицами. Чтобы избежать такого поведения, можно добавить дополнительный параметр ALL, который позволяет оставлять повторения
строк из двух объединенных таблиц.

Для корректной работы UNION нужно, чтобы результирующие таблицы каждого из SQL запросов имели одинаковое число столбцов, с одним и тем же типом данных и в той же самой 
последовательности.

Есть два схожих с UNION оператора:
    INTERSECT - комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые имеют совпадения во втором элементе SELECT.
    EXCEPT - комбинирует два запроса SELECT, но возвращает записи только первого SELECT, которые не имеют совпадения во втором элементе SELECT.



------------------------------------------------------------------------Условная логика, оператор CASE----------------------------------------------------------------------

SQL, подобно многим языкам программирования, позволяет писать условную логику, чтобы в зависимости от набора условий возвращать одно из множества возможных значений.
Аналог конструкции switch(){ case : } в JavaScript.

Например, у нас есть таблица студентов и нам нужно отобразить в результирующей таблице для каждого студента фиксированное значение "Совершеннолетний" либо 
"Несовершеннолетний". Для этого и существуют условные конструкции. Исходя из нашего примера, нам понадобится указать два возможных варианта по которым программа должна
работать.

Для поля которое мы хотим динамически задавать исходя из условного выражения мы должны использовать конструкцию:
    CASE 
        WHEN AGE >= 18 THEN "Совершеннолетний"
        ELSE "Несовершеннолетний"
    END AS название_столбца
Конструкция начинается с ключевого слова CASE, внутри каждое условие кроме последнего начинается с ключевого слова WHEN, а затем содержит условие, после которого идет
ключевое слово THEN + что_нужно_вернуть (если данное условие отработало). Последнее условие (исключающее все остальные), как и в JS, задается ключевым словом ELSE.
И далее конструкция закрывает с помощью ключевого слова END. После чего указывается псевдоним для столбца в котором будут отображены значения условной конструкции. 

Т.е. полный синтаксис запроса выглядит так:

    -------------------------------------------------------------------------------
    SELECT first_name, last_name,
    CASE
        WHEN TIMESTAMPDIFF(YEAR, birthday, NOW()) >= 18 THEN "Совершеннолетний"
        ELSE "Несовершеннолетний"
    END AS is_adult
    FROM Students
    -------------------------------------------------------------------------------

Синтаксис условного выражения:
    -------------------------------------------------------------------------------
    CASE
        WHEN условие_1 THEN возвращаемое_значение_1
        WHEN условие_2 THEN возвращаемое_значение_2
        WHEN условие_n THEN возвращаемое_значение_n
        [ELSE возвращаемое_значение_по_умолчанию]
    END
    -------------------------------------------------------------------------------

Как видно из приимера использование ELSE - опционально.

Для простого сравнения с помощью оператора "=" можно использовать упрощенный синтаксис. 
    -------------------------------------------------------------------------------
    CASE ЗНАЧЕНИЕ
        WHEN сравниваемое_значение THEN возвращаемое_значение_1
        WHEN сравниваемое_значение THEN возвращаемое_значение_2
        WHEN сравниваемое_значение THEN возвращаемое_значение_n
        [ELSE возвращаемое_значение_по_умолчанию]
    END
    -------------------------------------------------------------------------------



---------------------------------------------------------------------------Условная функция IF------------------------------------------------------------------------------

Для создания условной логики в SQL помимо CASE также применяется конструкция IF. Синтаксис следующий:

    -------------------------------------------------------------------------------
    IF(условное_выражение, значение_1, значение_2);
    -------------------------------------------------------------------------------

Если условное выражение передаваемое в качестве первого параметра в функцию истинно, то вернется значение_1, а если нет, то вернется значение_2. Важно отметить, что эта 
конструкция является функцией. Её также можно переписать с помощью CASE:

    -------------------------------------------------------------------------------
    CASE
        WHEN условное_выражение = TRUE THEN значение_1
        ELSE значение_2
    -------------------------------------------------------------------------------

Простой пример сравнения двух чисел:

    -------------------------------------------------------------------------------
    SELECT IF(10 > 20, "TRUE", "FALSE");
    -------------------------------------------------------------------------------

Очевидно, что в качестве возвращаемых значений можно использовать более серьезные конструкции чем простые строковые литералы.

Вот реальный пример, того как данная конструкция может помочь выставить соответствующий статус жилья для каждой квартиры:

    -------------------------------------------------------------------------------
    SELECT id, price,
    IF(price >= 150, "Комфорт-класс", "Эконом-класс") AS status_of_flat
    FROM Rooms
    -------------------------------------------------------------------------------

На концепции функции IF написаны еще две функции. IFNULL и NULLIF. 

Функция IFNULL возвращает значение, переданное первым аргументом, если оно не равно NULL, иначе возвращает альтернативное_значение.
    IFNULL(значение, другое_значение_которое_вернется_если_первое_значение_NULL);
Если первый аргумент не равен NULL, то вернется именно он

Функция NULLIF возвращает NULL, если значение_1 равно значению_2, в противном случае возвращает значение_1.
    NULLIF(значение_1, значение_2);